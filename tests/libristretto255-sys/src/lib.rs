//! Rust binding to libristretto255 intended for testing
//!
//! Automatically generated by rust-bindgen, however bindgen doesn't presently
//! support `#[repr(align)]`, so the resulting bindings have been checked-in.

#![crate_name = "libristretto255_sys"]
#![crate_type = "rlib"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

#[cfg(not(target_pointer_width = "64"))]
compile_error!("This binding assumes a 64-bit architecture");

pub const RISTRETTO_WORD_BITS: u32 = 64;
pub const RISTRETTO255_SCALAR_LIMBS: u32 = 4;
pub const RISTRETTO255_SCALAR_BITS: u32 = 253;
pub const RISTRETTO255_SER_BYTES: u32 = 32;
pub const RISTRETTO255_HASH_BYTES: u32 = 32;
pub const RISTRETTO255_SCALAR_BYTES: u32 = 32;
pub const RISTRETTO255_INVERT_ELLIGATOR_WHICH_BITS: u32 = 5;
pub const RISTRETTO255_REMOVED_COFACTOR: u32 = 8;

pub type ristretto_word_t = u64;
pub type ristretto_sword_t = i64;
pub type ristretto_bool_t = u64;
pub type ristretto_dword_t = u128;
pub type ristretto_dsword_t = i128;

extern "C" {
    pub static mut RISTRETTO_TRUE: ristretto_bool_t;
}

extern "C" {
    pub static mut RISTRETTO_FALSE: ristretto_bool_t;
}

/// < The operation succeeded.
pub const RISTRETTO_SUCCESS: ristretto_error_t = -1;

/// < The operation failed.
pub const RISTRETTO_FAILURE: ristretto_error_t = 0;
/// Another boolean type used to indicate success or failure.

pub type ristretto_error_t = i32;

extern "C" {
    /// Overwrite data with zeros.  Uses memset_s if available.
    pub fn ristretto_bzero(data: *mut ::std::os::raw::c_void, size: usize);
}

#[repr(C, align(32))]
#[derive(Debug, Copy, Clone)]
pub struct gf_25519_t {
    pub limb: [ristretto_word_t; 5usize],
    pub __bindgen_padding_0: [u64; 3usize],
}

#[test]
fn bindgen_test_layout_gf_25519_t() {
    assert_eq!(
        ::std::mem::size_of::<gf_25519_t>(),
        64usize,
        concat!("Size of: ", stringify!(gf_25519_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gf_25519_t>())).limb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gf_25519_t),
            "::",
            stringify!(limb)
        )
    );
}

/// Representation of a point on the elliptic curve.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ristretto255_point_t {
    /// @cond internal
    pub x: gf_25519_t,
    /// @cond internal
    pub y: gf_25519_t,
    /// @cond internal
    pub z: gf_25519_t,
    /// @cond internal
    pub t: gf_25519_t,
}

#[test]
fn bindgen_test_layout_ristretto255_point_t() {
    assert_eq!(
        ::std::mem::size_of::<ristretto255_point_t>(),
        256usize,
        concat!("Size of: ", stringify!(ristretto255_point_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ristretto255_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ristretto255_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ristretto255_point_t>())).y as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ristretto255_point_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ristretto255_point_t>())).z as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ristretto255_point_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ristretto255_point_t>())).t as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ristretto255_point_t),
            "::",
            stringify!(t)
        )
    );
}

/// Precomputed table based on a point.  Can be trivial implementation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ristretto255_precomputed_s {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut ristretto255_sizeof_precomputed_s: usize;
    pub static mut ristretto255_alignof_precomputed_s: usize;
}

/// Representation of an element of the scalar field.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ristretto255_scalar_t {
    /// @cond internal
    pub limb: [ristretto_word_t; 4usize],
}

#[test]
fn bindgen_test_layout_ristretto255_scalar_t() {
    assert_eq!(
        ::std::mem::size_of::<ristretto255_scalar_t>(),
        32usize,
        concat!("Size of: ", stringify!(ristretto255_scalar_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ristretto255_scalar_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ristretto255_scalar_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ristretto255_scalar_t>())).limb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ristretto255_scalar_t),
            "::",
            stringify!(limb)
        )
    );
}

extern "C" {
    pub static mut ristretto255_scalar_one: ristretto255_scalar_t;
    pub static mut ristretto255_scalar_zero: ristretto255_scalar_t;
    pub static mut ristretto255_point_identity: ristretto255_point_t;
    pub static mut ristretto255_point_base: ristretto255_point_t;
    pub static mut ristretto255_precomputed_base: *const ristretto255_precomputed_s;

    /// @brief Read a scalar from wire format or from bytes.
    ///
    /// @param [in] ser Serialized form of a scalar.
    /// @param [out] out Deserialized form.
    ///
    /// @retval RISTRETTO_SUCCESS The scalar was correctly encoded.
    /// @retval RISTRETTO_FAILURE The scalar was greater than the modulus,
    /// and has been reduced modulo that modulus.
    pub fn ristretto255_scalar_decode(
        out: *mut ristretto255_scalar_t,
        ser: *const ::std::os::raw::c_uchar,
    ) -> ristretto_error_t;

    /// @brief Read a scalar from wire format or from bytes.  Reduces mod
    /// scalar prime.
    ///
    /// @param [in] ser Serialized form of a scalar.
    /// @param [in] ser_len Length of serialized form.
    /// @param [out] out Deserialized form.
    pub fn ristretto255_scalar_decode_long(
        out: *mut ristretto255_scalar_t,
        ser: *const ::std::os::raw::c_uchar,
        ser_len: usize,
    );

    /// @brief Serialize a scalar to wire format.
    ///
    /// @param [out] ser Serialized form of a scalar.
    /// @param [in] s Deserialized scalar.
    pub fn ristretto255_scalar_encode(
        ser: *mut ::std::os::raw::c_uchar,
        s: *const ristretto255_scalar_t,
    );

    /// @brief Add two scalars.  The scalars may use the same memory.
    /// @param [in] a One scalar.
    /// @param [in] b Another scalar.
    /// @param [out] out a+b.
    pub fn ristretto255_scalar_add(
        out: *mut ristretto255_scalar_t,
        a: *const ristretto255_scalar_t,
        b: *const ristretto255_scalar_t,
    );

    /// @brief Compare two scalars.
    /// @param [in] a One scalar.
    /// @param [in] b Another scalar.
    /// @retval RISTRETTO_TRUE The scalars are equal.
    /// @retval RISTRETTO_FALSE The scalars are not equal.
    pub fn ristretto255_scalar_eq(
        a: *const ristretto255_scalar_t,
        b: *const ristretto255_scalar_t,
    ) -> ristretto_bool_t;

    /// @brief Subtract two scalars.  The scalars may use the same memory.
    /// @param [in] a One scalar.
    /// @param [in] b Another scalar.
    /// @param [out] out a-b.
    pub fn ristretto255_scalar_sub(
        out: *mut ristretto255_scalar_t,
        a: *const ristretto255_scalar_t,
        b: *const ristretto255_scalar_t,
    );

    /// @brief Multiply two scalars.  The scalars may use the same memory.
    /// @param [in] a One scalar.
    /// @param [in] b Another scalar.
    /// @param [out] out a*b.
    pub fn ristretto255_scalar_mul(
        out: *mut ristretto255_scalar_t,
        a: *const ristretto255_scalar_t,
        b: *const ristretto255_scalar_t,
    );

    /// @brief Halve a scalar.  The scalars may use the same memory.
    /// @param [in] a A scalar.
    /// @param [out] out a/2.
    pub fn ristretto255_scalar_halve(
        out: *mut ristretto255_scalar_t,
        a: *const ristretto255_scalar_t,
    );

    /// @brief Invert a scalar.  When passed zero, return 0.  The input and output may alias.
    /// @param [in] a A scalar.
    /// @param [out] out 1/a.
    /// @return RISTRETTO_SUCCESS The input is nonzero.
    pub fn ristretto255_scalar_invert(
        out: *mut ristretto255_scalar_t,
        a: *const ristretto255_scalar_t,
    ) -> ristretto_error_t;

    /// @brief Set a scalar to an unsigned 64-bit integer.
    /// @param [in] a An integer.
    /// @param [out] out Will become equal to a.
    pub fn ristretto255_scalar_set_unsigned(out: *mut ristretto255_scalar_t, a: u64);

    /// @brief Encode a point as a sequence of bytes.
    ///
    /// @param [out] ser The byte representation of the point.
    /// @param [in] pt The point to encode.
    pub fn ristretto255_point_encode(ser: *mut u8, pt: *const ristretto255_point_t);

    /// @brief Decode a point from a sequence of bytes.
    ///
    /// Every point has a unique encoding, so not every
    /// sequence of bytes is a valid encoding.  If an invalid
    /// encoding is given, the output is undefined.
    ///
    /// @param [out] pt The decoded point.
    /// @param [in] ser The serialized version of the point.
    /// @param [in] allow_identity RISTRETTO_TRUE if the identity is a legal input.
    /// @retval RISTRETTO_SUCCESS The decoding succeeded.
    /// @retval RISTRETTO_FAILURE The decoding didn't succeed, because
    /// ser does not represent a point.
    pub fn ristretto255_point_decode(
        pt: *mut ristretto255_point_t,
        ser: *const u8,
        allow_identity: ristretto_bool_t,
    ) -> ristretto_error_t;

    /// @brief Test whether two points are equal.  If yes, return
    /// RISTRETTO_TRUE, else return RISTRETTO_FALSE.
    ///
    /// @param [in] a A point.
    /// @param [in] b Another point.
    /// @retval RISTRETTO_TRUE The points are equal.
    /// @retval RISTRETTO_FALSE The points are not equal.
    pub fn ristretto255_point_eq(
        a: *const ristretto255_point_t,
        b: *const ristretto255_point_t,
    ) -> ristretto_bool_t;

    /// @brief Add two points to produce a third point.  The
    /// input points and output point can be pointers to the same
    /// memory.
    ///
    /// @param [out] sum The sum a+b.
    /// @param [in] a An addend.
    /// @param [in] b An addend.
    pub fn ristretto255_point_add(
        sum: *mut ristretto255_point_t,
        a: *const ristretto255_point_t,
        b: *const ristretto255_point_t,
    );

    /// @brief Double a point.  Equivalent to
    /// ristretto255_point_add(two_a,a,a), but potentially faster.
    ///
    /// @param [out] two_a The sum a+a.
    /// @param [in] a A point.
    pub fn ristretto255_point_double(
        two_a: *mut ristretto255_point_t,
        a: *const ristretto255_point_t,
    );

    /// @brief Subtract two points to produce a third point.  The
    /// input points and output point can be pointers to the same
    /// memory.
    ///
    /// @param [out] diff The difference a-b.
    /// @param [in] a The minuend.
    /// @param [in] b The subtrahend.
    pub fn ristretto255_point_sub(
        diff: *mut ristretto255_point_t,
        a: *const ristretto255_point_t,
        b: *const ristretto255_point_t,
    );

    /// @brief Negate a point to produce another point.  The input
    /// and output points can use the same memory.
    ///
    /// @param [out] nega The negated input point
    /// @param [in] a The input point.
    pub fn ristretto255_point_negate(
        nega: *mut ristretto255_point_t,
        a: *const ristretto255_point_t,
    );

    /// @brief Multiply a base point by a scalar: scaled = scalar*base.
    ///
    /// @param [out] scaled The scaled point base*scalar
    /// @param [in] base The point to be scaled.
    /// @param [in] scalar The scalar to multiply by.
    pub fn ristretto255_point_scalarmul(
        scaled: *mut ristretto255_point_t,
        base: *const ristretto255_point_t,
        scalar: *const ristretto255_scalar_t,
    );

    /// @brief Multiply a base point by a scalar: scaled = scalar*base.
    /// This function operates directly on serialized forms.
    ///
    /// @warning This function is experimental.  It may not be supported
    /// long-term.
    ///
    /// @param [out] scaled The scaled point base*scalar
    /// @param [in] base The point to be scaled.
    /// @param [in] scalar The scalar to multiply by.
    /// @param [in] allow_identity Allow the input to be the identity.
    /// @param [in] short_circuit Allow a fast return if the input is illegal.
    ///
    /// @retval RISTRETTO_SUCCESS The scalarmul succeeded.
    /// @retval RISTRETTO_FAILURE The scalarmul didn't succeed, because
    /// base does not represent a point.
    pub fn ristretto255_direct_scalarmul(
        scaled: *mut u8,
        base: *const u8,
        scalar: *const ristretto255_scalar_t,
        allow_identity: ristretto_bool_t,
        short_circuit: ristretto_bool_t,
    ) -> ristretto_error_t;

    /// @brief Precompute a table for fast scalar multiplication.
    /// Some implementations do not include precomputed points; for
    /// those implementations, this implementation simply copies the
    /// point.
    ///
    /// @param [out] a A precomputed table of multiples of the point.
    /// @param [in] b Any point.
    pub fn ristretto255_precompute(
        a: *mut ristretto255_precomputed_s,
        b: *const ristretto255_point_t,
    );

    /// @brief Multiply a precomputed base point by a scalar:
    /// scaled = scalar*base.
    /// Some implementations do not include precomputed points; for
    /// those implementations, this function is the same as
    /// ristretto255_point_scalarmul
    ///
    /// @param [out] scaled The scaled point base*scalar
    /// @param [in] base The point to be scaled.
    /// @param [in] scalar The scalar to multiply by.
    pub fn ristretto255_precomputed_scalarmul(
        scaled: *mut ristretto255_point_t,
        base: *const ristretto255_precomputed_s,
        scalar: *const ristretto255_scalar_t,
    );

    /// @brief Multiply two base points by two scalars:
    /// scaled = scalar1*base1 + scalar2*base2.
    ///
    /// Equivalent to two calls to ristretto255_point_scalarmul, but may be
    /// faster.
    ///
    /// @param [out] combo The linear combination scalar1*base1 + scalar2*base2.
    /// @param [in] base1 A first point to be scaled.
    /// @param [in] scalar1 A first scalar to multiply by.
    /// @param [in] base2 A second point to be scaled.
    /// @param [in] scalar2 A second scalar to multiply by.
    pub fn ristretto255_point_double_scalarmul(
        combo: *mut ristretto255_point_t,
        base1: *const ristretto255_point_t,
        scalar1: *const ristretto255_scalar_t,
        base2: *const ristretto255_point_t,
        scalar2: *const ristretto255_scalar_t,
    );

    /// Multiply one base point by two scalars:
    ///
    /// a1 = scalar1 * base
    /// a2 = scalar2 * base
    ///
    /// Equivalent to two calls to ristretto255_point_scalarmul, but may be
    /// faster.
    ///
    /// @param [out] a1 The first multiple.  It may be the same as the input point.
    /// @param [out] a2 The second multiple.  It may be the same as the input point.
    /// @param [in] base1 A point to be scaled.
    /// @param [in] scalar1 A first scalar to multiply by.
    /// @param [in] scalar2 A second scalar to multiply by.
    pub fn ristretto255_point_dual_scalarmul(
        a1: *mut ristretto255_point_t,
        a2: *mut ristretto255_point_t,
        base1: *const ristretto255_point_t,
        scalar1: *const ristretto255_scalar_t,
        scalar2: *const ristretto255_scalar_t,
    );

    /// @brief Multiply two base points by two scalars:
    /// scaled = scalar1*ristretto255_point_base + scalar2*base2.
    ///
    /// Otherwise equivalent to ristretto255_point_double_scalarmul, but may be
    /// faster at the expense of being variable time.
    ///
    /// @param [out] combo The linear combination scalar1*base + scalar2*base2.
    /// @param [in] scalar1 A first scalar to multiply by.
    /// @param [in] base2 A second point to be scaled.
    /// @param [in] scalar2 A second scalar to multiply by.
    ///
    /// @warning: This function takes variable time, and may leak the scalars
    /// used.  It is designed for signature verification.
    pub fn ristretto255_base_double_scalarmul_non_secret(
        combo: *mut ristretto255_point_t,
        scalar1: *const ristretto255_scalar_t,
        base2: *const ristretto255_point_t,
        scalar2: *const ristretto255_scalar_t,
    );

    /// @brief Constant-time decision between two points.  If pick_b
    /// is zero, out = a; else out = b.
    ///
    /// @param [out] out The output.  It may be the same as either input.
    /// @param [in] a Any point.
    /// @param [in] b Any point.
    /// @param [in] pick_b If nonzero, choose point b.
    pub fn ristretto255_point_cond_sel(
        out: *mut ristretto255_point_t,
        a: *const ristretto255_point_t,
        b: *const ristretto255_point_t,
        pick_b: ristretto_word_t,
    );

    /// @brief Constant-time decision between two scalars.  If pick_b
    /// is zero, out = a; else out = b.
    ///
    /// @param [out] out The output.  It may be the same as either input.
    /// @param [in] a Any scalar.
    /// @param [in] b Any scalar.
    /// @param [in] pick_b If nonzero, choose scalar b.
    pub fn ristretto255_scalar_cond_sel(
        out: *mut ristretto255_scalar_t,
        a: *const ristretto255_scalar_t,
        b: *const ristretto255_scalar_t,
        pick_b: ristretto_word_t,
    );

    /// @brief Test that a point is valid, for debugging purposes.
    ///
    /// @param [in] to_test The point to test.
    /// @retval RISTRETTO_TRUE The point is valid.
    /// @retval RISTRETTO_FALSE The point is invalid.
    pub fn ristretto255_point_valid(to_test: *const ristretto255_point_t) -> ristretto_bool_t;

    /// @brief Torque a point, for debugging purposes.  The output
    /// will be equal to the input.
    ///
    /// @param [out] q The point to torque.
    /// @param [in] p The point to torque.
    pub fn ristretto255_point_debugging_torque(
        q: *mut ristretto255_point_t,
        p: *const ristretto255_point_t,
    );

    /// @brief Projectively scale a point, for debugging purposes.
    /// The output will be equal to the input, and will be valid
    /// even if the factor is zero.
    ///
    /// @param [out] q The point to scale.
    /// @param [in] p The point to scale.
    /// @param [in] factor Serialized GF factor to scale.
    pub fn ristretto255_point_debugging_pscale(
        q: *mut ristretto255_point_t,
        p: *const ristretto255_point_t,
        factor: *const ::std::os::raw::c_uchar,
    );

    /// @brief Almost-Elligator-like hash to curve.
    ///
    /// Call this function with the output of a hash to make a hash to the curve.
    ///
    /// This function runs Elligator2 on the ristretto255 Jacobi quartic model.  It then
    /// uses the isogeny to put the result in twisted Edwards form.  As a result,
    /// it is safe (cannot produce points of order 4), and would be compatible with
    /// hypothetical other implementations of Decaf using a Montgomery or untwisted
    /// Edwards model.
    ///
    /// Unlike Elligator, this function may be up to 4:1 on [0,(p-1)/2]:
    /// A factor of 2 due to the isogeny.
    /// A factor of 2 because we quotient out the 2-torsion.
    ///
    /// This makes it about 8:1 overall, or 16:1 overall on curves with cofactor 8.
    ///
    /// Negating the input (mod q) results in the same point.  Inverting the input
    /// (mod q) results in the negative point.  This is the same as Elligator.
    ///
    /// This function isn't quite indifferentiable from a random oracle.
    /// However, it is suitable for many protocols, including SPEKE and SPAKE2 EE.
    /// Furthermore, calling it twice with independent seeds and adding the results
    /// is indifferentiable from a random oracle.
    ///
    /// @param [in] hashed_data Output of some hash function.
    /// @param [out] pt The data hashed to the curve.
    pub fn ristretto255_point_from_hash_nonuniform(
        pt: *mut ristretto255_point_t,
        hashed_data: *const ::std::os::raw::c_uchar,
    );

    /// @brief Indifferentiable hash function encoding to curve.
    ///
    /// Equivalent to calling ristretto255_point_from_hash_nonuniform twice and adding.
    ///
    /// @param [in] hashed_data Output of some hash function.
    /// @param [out] pt The data hashed to the curve.
    pub fn ristretto255_point_from_hash_uniform(
        pt: *mut ristretto255_point_t,
        hashed_data: *const ::std::os::raw::c_uchar,
    );

    /// @brief Inverse of elligator-like hash to curve.
    ///
    /// This function writes to the buffer, to make it so that
    /// ristretto255_point_from_hash_nonuniform(buffer) = pt if
    /// possible.  Since there may be multiple preimages, the
    /// "which" parameter chooses between them.  To ensure uniform
    /// inverse sampling, this function succeeds or fails
    /// independently for different "which" values.
    ///
    /// This function isn't guaranteed to find every possible
    /// preimage, but it finds all except a small finite number.
    /// In particular, when the number of bits in the modulus isn't
    /// a multiple of 8 (i.e. for curve25519), it sets the high bits
    /// independently, which enables the generated data to be uniform.
    /// But it doesn't add p, so you'll never get exactly p from this
    /// function.  This might change in the future, especially if
    /// we ever support eg Brainpool curves, where this could cause
    /// real nonuniformity.
    ///
    /// @param [out] recovered_hash Encoded data.
    /// @param [in] pt The point to encode.
    /// @param [in] which A value determining which inverse point
    /// to return.
    ///
    /// @retval RISTRETTO_SUCCESS The inverse succeeded.
    /// @retval RISTRETTO_FAILURE The inverse failed.
    pub fn ristretto255_invert_elligator_nonuniform(
        recovered_hash: *mut ::std::os::raw::c_uchar,
        pt: *const ristretto255_point_t,
        which: u32,
    ) -> ristretto_error_t;

    /// @brief Inverse of elligator-like hash to curve.
    ///
    /// This function writes to the buffer, to make it so that
    /// ristretto255_point_from_hash_uniform(buffer) = pt if
    /// possible.  Since there may be multiple preimages, the
    /// "which" parameter chooses between them.  To ensure uniform
    /// inverse sampling, this function succeeds or fails
    /// independently for different "which" values.
    ///
    /// @param [out] recovered_hash Encoded data.
    /// @param [in] pt The point to encode.
    /// @param [in] which A value determining which inverse point
    /// to return.
    ///
    /// @retval RISTRETTO_SUCCESS The inverse succeeded.
    /// @retval RISTRETTO_FAILURE The inverse failed.
    pub fn ristretto255_invert_elligator_uniform(
        recovered_hash: *mut ::std::os::raw::c_uchar,
        pt: *const ristretto255_point_t,
        which: u32,
    ) -> ristretto_error_t;

    /// Securely erase a scalar.
    pub fn ristretto255_scalar_destroy(scalar: *mut ristretto255_scalar_t);

    /// Securely erase a point by overwriting it with zeros.
    /// @warning This causes the point object to become invalid.
    pub fn ristretto255_point_destroy(point: *mut ristretto255_point_t);

    /// Securely erase a precomputed table by overwriting it with zeros.
    /// @warning This causes the table object to become invalid.
    pub fn ristretto255_precomputed_destroy(pre: *mut ristretto255_precomputed_s);
}
